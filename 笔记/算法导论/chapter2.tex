\chapter{排序算法}
现实中的许多应用需要对数据进行排序。同时，许多算法中也包含了“排序”这一子步骤。因此，研究排序算法十分重要。
有许多排序算法，评价它们的质量好坏主要依据一下几个指标：时间复杂度，所需附加存储，复杂性。

排序算法的时间复杂度主要体现在所需的平均比较次数和平均移动次序上。如果一个算法所需的平均辅助存储不随输入规模变化而变化，
则称该算法为原地算法。如果一个排序算法在排序过程中，会直接将待排序的最大（小）元素调整至它的最终位置，则称该排序算法具有部分排序功能。如果一个排序
算法不会改变排序依据——关键字——相同的数据的相对位置，则称该排序算法具有稳定性。
\section{插入排序及其变形}
\subsection{直接插入排序}
在整理手牌时，我们常用直接插入排序。它的核心思想为：不断将未排序的数据以不破坏排序的方式插入到已排序的数据中。其伪代码如下：

\begin{algorithm}[H]
    \tcp*[h]{A为待排序序列}\;
    \For{j = 2 \KwTo A.length}
    {
        key = A[j]\;
        i = j - 1\;
        \While{i > 0 and A[i] > 0}
        {
            A[i + 1] = A[i]\;
            i = i - 1\;
        }
        A[i + 1] = key\;
    }
    \caption{Insertion-Sort}
\end{algorithm}

平均情况下， $A[i]$需要向前移动 $i/2$个位置。因此，平均时间复杂度为 $O(n^2)$。易知，该算法为原地算法，且具有稳定性，但是不具有部分排序功能。
\subsection{折半插入排序}
直接插入排序算法中的内层循环本质上是在寻找待插入的位置，因为待插入的是一个有序的子序列，所以我们可以在这一过程中使用二分法寻找待插入的位置，
而这便是折半插入排序算法。

折半插入排序有较优的\emph{平均比较次数}—— $O(n\lg n)$，其中折半查找的时间复杂度为 $O(\lg n)$。但是，无论数据初始状态如何，该算法始终会执行
折半查找，即使我们输入的是有序的序列（该情况会使得折半插入排序算法达到最坏时间复杂度，但是对于排序算法却能达到最优时间复杂度）。

由于折半插入排序只改变了直接插入排序中寻找插入位置的方法，所以它仍为原地算法，且具有稳定性，但仍不具有部分排序功能。
同时，它的\emph{平均移动次数仍为 $O(n^2)$。}
\subsection{希尔排序}
直接插入排序中“将未排序数据插入已排序数据”这一步可以理解为“通过不断交换待插入元素和与它相邻的数据，使其移动到待插入的位置”。
易知，这样的每一次交换都消去了一对逆序对，而当逆序对全部消去时，我们便完成了排序。因为直接插入排序中的每次操作只能消去一对逆序对，如果
能够改进算法，使得每次操作能消去多对逆序对，我们便能获得更高效的算法，而这便是希尔排序的改进之处。

希尔算法的核心思想是：设定一个严格单调递减至1的间隔数序列，遍历这个间隔数序列：对于每个间隔数，将待排序序列分割成多个子序列，每个序列的下标是以间隔数
为公差的等差数列，然后对每个子序列进行直接插入排序。

当间隔数较大时，子序列中的一次操作能够消去多对逆序对；当间隔数较小时，只需在之前的基础上进行微调即可，从而整体的时间复杂度较优。
\begin{myrmk}
    间隔数序列设定的方法尚无定论。但是如果间隔数之间成倍数关系的话，可能会导致对于某些间隔数无需排序子序列，即产生冗余，所以一种策略是选取互素的间隔数。
\end{myrmk}
由于关键字相同的数据可能位于两个子序列中，因此希尔排序无法保证稳定性。
\begin{myrmk}
    虽然算法并没有对具体实现的细节作要求，但是实现的细节要符合算法的思想。插入算法的思想就是“插入”——
    将目前排序的元素提取出来，其他元素依次平移，\emph{而不是用swap进行交换}。
\end{myrmk}
\section{交换排序}
交换排序的基本思想是：两两比较待排序对象的关键字，如果发生逆序(即排
列顺序与排序后的次序正好相反)，则交换之，直到所
有对象都排好序为止。

\subsection{冒泡排序}
基本思想是：进行 $n-1$次循环，每次循环从序列首元素开始，通过前后交换，将当前遇到的最大元素移动到序列末端。
\begin{algorithm}
    \SetKwFunction{Swap}{Swap}
    \SetKw{break}{break}
    \For{i = 1 \KwTo nums.length-1}
    {
        change = 0
        \For{j = 1 \KwTo nums.length-1}
        {
            \lIf{nums[j+1]<nums[j]}{\Swap(nums[j],nums[j+1])}    
            change = 1\;
        }
        \lIf{change == 0}{\break}
    }
    \caption{Bubble-Sort(nums)}
\end{algorithm}
\begin{myrmk}
    这里设置 $change$变量来辅助判断排序是否已经完成。
\end{myrmk}
\begin{myrmk}
    许多排序算法，尤其是具有部分排序功能的，只需要进行 $n-1$轮循环即可，因为找出排出前 $n-1$大的数也就表明整个序列已经排序完成。
\end{myrmk}
\subsection{快速排序}
快速排序算法利用了分治法，其主要思想是：将一个枢纽元素调整至最终的位置，并且确保其他元素和它的相对位置也是正确的，
然后对位于其左右的子序列再次进行快速排序。

\begin{algorithm}
    \SetKwFunction{Quick}{Quick-Sort}
    \If{l<r}
    {
        p = Partition(A,l,r)\;
        \Quick(A,l,p-1)\;
        \Quick(A,p+1,r)\;
    }
   \caption{Quick-Sort(A,l,r)} 
\end{algorithm}
\begin{function}[H]
    \SetKwFunction{Swap}{Swap}
    \tcp*[h]{默认以最后一个元素作为pivot;l,r分别为子序列的左右端点下标}\;
    \tcp*[h]{返回pivot的最终下标}\;
    i = l - 1\;
    \For{j = l \KwTo r-1}
    {
        \If(\tcp*[h]{使用自定义的比较规则}){Compare(A[j],A[r])}
        {
            i = i + 1\;
            \Swap(A[j],A[i])\;
        }
    }
    \Swap(A[i+1],A[r])\;
    \KwRet{i+1}
    \caption{Partition(A,l,r)}
\end{function}
快速排序是一种不稳定的排序方式。最坏情况下，它会退化为选择排序。为了避免出现子问题规模不均而退化为选择排序，通常会将该算法
随机化，即随机挑选枢纽元素。

\section{选择排序}
选择排序的基本思想是：每一轮选出一个待排序元素，然后直接将其放入最终的位置。与插入排序和交换排序不同的是，在选择排序算法中，
比较过程中不会移动元素位置。
\subsection{直接选择排序}
\begin{algorithm}
    \For{i = 1 \KwTo nums.length-1}
    {
        min = i\;
        \For{j = i+1 \KwTo nums.length}
        {
            \lIf{nums[j]<nums[min]}{min = j}
        }
        \lIf{min $\neq$ i}{\Swap(nums[min],nums[i])}
    } 
    \caption{Select-Sort(nums)}
\end{algorithm}
直接选择排序是一种不稳定的排序方式。
\subsection{锦标赛排序}
锦标赛排序所用的数据结构是满二叉树，树上的元素包含排序关键字，关键字对应的叶子节点的下标以及
是否已经排序完成的标志。

初始状态是将待排序元素放置在叶子结点上，若未满则用不参加排序的元素占位。
然后通过兄弟节点两两比较，较小者成为父节点。建好树后便通过取根节点元素获取当前的最小元素。
每取一次后，读取对应的叶子结点下标，从该叶子节点开始向上至根节点，设置完成排序的标志，并和兄弟结点比较，判断是否需要更新整个结点。

建树的时间复杂度和结点个数成正比，为 $\Theta(n)$，而每次循环需要 $O(\lg n)$，所以总的时间复杂度是 $O(n\lg n)$。需要的额外存储空间为 $\Theta(n)$.
\subsection{堆排序}
堆排序所用的数据结构是完全二叉树。树上的元素只要有关键字即可。

初始状态时，将待排序元素依次从根节点开始放置到树上，然后从最后一个非叶子结点开始，依次执行“堆化”，确保满足性质：父节点大于孩子节点，
如果发生调整，则需要对孩子节点进行迭代调整。建堆完成后，每次从根节点能取出目前的最大元素，将其和目前的末端元素互换，并缩小树的大小，
然后再对新的根节点进行“堆化”。

可以证明，建堆的时间复杂度为 $\Theta(n)$，而排序的时间复杂度则是 $\Theta(n\lg n)$。

堆排序不具有稳定性，但是无需额外存储空间。
\section{归并排序}
使用递归实现，是一种稳定的排序方式，但是需要 $\Theta(n)$的额外存储空间。

基本思想是将排序一个序列的问题转化为排序两个左右子列的问题，然后将这两个有序序列合并为一个有序序列的问题。
\section{基数排序}
基数排序适用于多关键字排序。

多关键字排序的实现主要分为“最高位优先”和“最低位优先”。

进行最高位优先排序时，需要保存高位排序得到的结果，在其内部进行更低位的排序，这对存储效率提出较高要求。

在进行最低位优先排序时，需要确保各位所用的排序算法具有稳定性，不会破坏低位排序得到的相对位置关系。实现时常常采用链表作为数据结构：
用一个链表存储每次的排序结果；用与关键词个数数量相同的多个链表来存储排序的中间过程。