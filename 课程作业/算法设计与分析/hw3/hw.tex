\documentclass[12pt, a4paper, oneside]{article}
\usepackage{amsmath, amsthm, amssymb, bm, graphicx, hyperref, mathrsfs}
\makeatletter
\newcommand{\mytitle}{\@title}
\makeatother

\usepackage[
    fontset=none,%设置中文支持，并自定义字体
    zihao=5,%默认字号为五号
    heading=true,%允许后续自定义标题样式
    scheme=chinese,%自动将文档样式中文化，例如图标标题
    punct=quanjiao,%全角式标点符号
    space=auto,%中文后接换行不会添加空格，但是英文会添加空格，需要用%手动取消
    linespread=1.3,%行距倍数是1.3
    autoindent=true,%自动缩进两个中文宽度
    ]{ctex}
\ctexset{
    today=small,%小写样式的日期
    contentsname={目录},
    % contentsname={\hspace{-\ccwd}目录},
    listfigurename={插图},
    listtablename={表格},
    figurename={图},
    tablename={表},
    abstractname={简{\quad}介},
    indexname={索引},
    appendixname={附录},
    bibname={参考文献},
    proofname={证明},
    % refname={参考文献},%只适用于beamer
    % algorithmname={算法},
    % continuation={（续）},%beamer续页的标识
    section={
        format+ = \Large\heiti\raggedright,
        name = {,\num\textbf{.}\hspace{1ex}},
        number={\num\thesection},
        nameformat={},
        numberformat={},
        aftername={},
        titleformat={},
        aftertitle={},
        runin=false,%对section级以下有用，标题是否和正文在同一段上
        beforeskip={3.5ex plus 1ex minus .2ex},%标题前垂直间距
        afterskip={2.3ex plus .2ex}%标题后垂直间距
    },
    subsection={
        format+ = \large\heiti\raggedright,
        name = {,\num\textbf{.}\hspace{1ex}},
        number={\num\thesubsection},
        nameformat={},
        numberformat={},
        aftername={},
        titleformat={},
        aftertitle={},
        runin=false,%对section级以下有用，标题是否和正文在同一段上
        beforeskip={3.5ex plus 1ex minus .2ex},%标题前垂直间距
        afterskip={2.3ex plus .2ex}%标题后垂直间距
    },
    subsubsection={
        format+ = \normalsize\heiti\raggedright,
        name = {,\num\textbf{.}\hspace{1ex}},
        number={\num\thesubsubsection},
        nameformat={},
        numberformat={},
        aftername={},
        titleformat={},
        aftertitle={},
        runin=false,%对section级以下有用，标题是否和正文在同一段上
        beforeskip={3.5ex plus 1ex minus .2ex},%标题前垂直间距
        afterskip={2.3ex plus .2ex}%标题后垂直间距
    },
    }

\title{\textbf{3-2(D)}}
\author{范潇\quad2254298}
\date{\today}
\linespread{1.5}
\newcounter{problemname}
\newenvironment{problem}[1]{\stepcounter{problemname}\par\noindent\textbf{题目\arabic{problemname}. (#1)}}{}
\newenvironment{solution}{\par\noindent\textbf{解答. }}{}
\newenvironment{note}{\par\noindent\textbf{题目\arabic{problemname}的注记. }}{}
\usepackage{amsfonts}
\usepackage{lmodern}%解决报错
% 中文默认字体： 思源宋体，粗体为思源宋体半粗体，斜体为方正楷体_GBK
\setCJKmainfont{Source Han Serif SC}[BoldFont={Source Han Serif SC Heavy}, ItalicFont=FZKai-Z03S]
% 中文无衬线字体：思源黑体，粗体为思源黑体粗体
\setCJKsansfont{Source Han Sans CN}[BoldFont={Source Han Sans CN Heavy}]
% 中文等宽字体：微软雅黑light
\setCJKmonofont{Microsoft YaHei}[ItalicFont={Microsoft YaHei Light}]

\newCJKfontfamily\songti{Source Han Serif SC}[BoldFont={Source Han Serif SC Heavy}]
\newCJKfontfamily\xbsong{Source Han Serif SC SemiBold} % 小标宋
\newCJKfontfamily\dbsong{Source Han Serif SC Bold} % 大标宋
\newCJKfontfamily\cusong{Source Han Serif SC Heavy} % 粗宋
\newCJKfontfamily\heiti{Source Han Sans CN}[BoldFont={Source Han Sans CN Heavy}]
\newCJKfontfamily\dahei{Source Han Sans CN Medium} % 大黑
\newCJKfontfamily\cuhei{Source Han Sans CN Heavy} % 粗黑
\newCJKfontfamily\fangsong{FZFangSong-Z02S}
\newCJKfontfamily\kaiti{FZKai-Z03S}[ItalicFont={Microsoft YaHei Light}]%这个斜体只是用于lstlisting环境中的中文注释
% \newCJKfontfamily\kaiti{FZKai-Z03S}[ItalicFont={FZZJ-LZXTFSJW}]%这个斜体只是用于lstlisting环境中的中文注释
\setsansfont{Arial}
\setmonofont{Consolas}%设置西文等宽字体
\newfontfamily\code{Consolas}
\newfontfamily\num{Arial}

\usepackage{geometry}%设置整体页面布局
\geometry{a4paper}
\geometry{left=2cm,right=2cm,top=2.54cm,bottom=2.54cm}%word常规页边距
% \geometry{left=1.27cm,right=1.27cm,top=1.27cm,bottom=1.27cm}%word窄页边距
\setlength{\headheight}{13pt}%避免warning
\usepackage{fancyhdr}%必须在geometry包之后使用
\fancyhf{}
\makeatletter
\lhead{\sffamily\bfseries{2254298 范潇}}%可以使用thepage,CTEXthechapter,CTEXthesection
\makeatother
\chead{\sffamily\bfseries{\mytitle}}
\rhead{\sffamily\bfseries{- \thepage{} -}}
\renewcommand\headrulewidth{2pt}%设置眉头宽度
\pagestyle{fancy}
\usepackage[ruled,lined,longend,fillcomment,linesnumbered,resetcount,titlenotnumbered]{algorithm2e}
%参数解释：带框，按section编码，有竖线，end前带if等关键词，注释占满整行，代码部分编号（不包括输入输出、注释），每个代码块重新编号，可以调用TitleOfAlgo来打印算法标题但不作为单独的算法编码
%附带algorithm,function,procedure环境,其中function,procedure环境下，设置caption时，必须带有()，
%()之前的字符会被视为宏，可以在接下来的部分用\名字()来调用，所以推荐辅助函数用function，其中的某些展开部分用procedure，描述算法整体使用algorithm
\DontPrintSemicolon
\SetAlCapSkip{2ex}
\SetSideCommentRight
\SetFillComment
\newcommand{\forcond}{$i=0$ \KwTo $n$}
\SetKw{macro}{text}%自定义关键词
\SetKwFunction{funcmacro}{text}%自定义函数名，实际上function环境是在定义宏的同时说明了其内容
\SetKwProg{procedmacro}{text}{begin text}{end text}%自定义步骤，和function类似，但是后面两个参数可以设置开始和结尾的标志，和if等环境一样
\SetKwData{datamacro}{text}%可以用于突出特殊的变量，例如数据结构
\SetKwFunction{FRecurs}{FnRecursive}
\SetKwProg{Fn}{Function}{begin}{end}
\begin{document}
\maketitle
\begin{problem}{最长单调子序列}
    设计一个$O(n\log n)$时间的算法，找出由$n$个数组成的序列的最长单调递增子序列。
\end{problem}
\begin{solution}
    在$O(n^2)$时间的算法中，dp数组用于记录以输入序列中的各个数为结尾的最长递增子序列，而在$O(n\log n)$时间的算法中，
    dp数组用于记录各个长度的递增子序列的末尾元素的最小值。

    假设输入序列中的元素为互异的正数。
    可以证明，在扫描输入序列时，总是存在$i$，使得dp[1..$i$]为非零单调递增序列，且dp中的其余元素均为0。事实上，如果存在$j<i$，使得dp[$j$]>dp[$i$]，
    由于dp[$i$]对应的子序列中的第$j$个元素$x$小于dp[$i$]对应的元素，同时，由其前$j$个元素组成的子序列仍是单调递增子序列，
    因此产生矛盾。同时由于递增子序列的任意长度的子序列仍是递增子序列，所以dp中的非零元素是连续的。
    扫描完输入序列后，dp中非零元素的个数便是最长递增子序列的长度。
    
    为了维护dp，扫描到的当前元素应该写入的位置是当前dp数组中第一个大于它的元素的位置，如果没有，则写入第一个0的位置（下标从1开始）。
    为了能够还原最长递增子序列，dp数组每次更新时，更新位置对应的递增子序列以新增元素为结尾，且倒数第二个元素便是前面一个位置中的当前元素。
    因此只需要额外用一个数组记录这个关系即可。

    伪代码在下一页中给出。其中在遍历输入序列时，使用了二分查找，所以时间复杂度为$O(n\log n)$。
    \begin{algorithm}
        \SetKwFunction{bisect}{bisect}
        \KwIn{A<$x_1,\cdots,x_n$>($x_i>0,i=1,\cdots,n$;$x_i\neq x_j,i\neq j$)}
        \KwOut{最长递增子序列之一}
        初始化dp\tcp*[h]{用于记录各个长度的递增子序列的末尾元素的最小值以及在输入序列中的下标}\;
        初始化pre\tcp*[h]{用于回溯形成最长递增子序列}\;
        dp[0].val = -1\tcp*[h]{哨兵}\;
        dp[0].no = -1\;
        i = 1\;
        \While{$i\leq n$}
        {
            pos = \bisect(dp,A[i])\;
            \tcp*[h]{当前dp数组中第一个大于它的元素的位置，若没有，则返回第一个0的位置}\;
            dp[pos].val = A[i]\;
            dp[pos].no = i\;
            pre[i] =  dp[pos-1].no\;
            i += 1\;
        }
        l = 0\;
        \lWhile(\tcp*[h]{求最长递增子序列长度}){dp[l+1]$\neq$0}{l += 1}
        cnt = l\;
        now = dp[l].no\;
        初始化LIS\;
        \While{now $\neq$ -1}
        {
            LIS[cnt] = A[now]\;
            cnt -= 1\;
            now = pre[now]\;
        }
        \KwRet{LIS}
        \caption{getLIS}
    \end{algorithm}
\end{solution}
\end{document}